# ConcurrentMapTest
회사에서 겪은 ConcurrentMap 동기화 상황 재연

### 문제 상황
+ redis 안에 데이터를 삭제해도 ConcurrentHashMap에는 반영이 안되는 문제 발생
+ 원인 파악
  + ConcurrentHashMap을 제어하는 클래스는 스케줄러가 있는 클래스에서 putAll()메소드만을 사용해 redis에선 삭제가 일어나도 감지를 못함
+ 기대 상황
  + 스케줄러 메소드가 돌 때 Redis에서 정보를 읽어와 기존에 ConcurrentHashMap에 있던 정보를 clear() 하여 모두 삭제하고 
putAll() 메소드로 새로운 정보를 넣을 때 synchronized()로 다른 클래스에서 이 객체에 대한 접근을 블록 
+ 실행 시
  + 스케줄러 메소드의 종료를 기다리지 않고 블록이 되지 않은 상태에서 객체의 값을 get() 해서 가져감.
+ 기대와 실행이 다른 원인
  + synchronized() 블록 범위의 오해
    + synchronized() 블록으로 객체를 감싼다고 공유 객체에 대한 전역적인 잠금이 이뤄지진 않는다.
    + 해당 메소드 (clearAndPut())에 대한 접근 중 공유 객체에 대한 접근만 블로킹 시킴


### 해결방안
1. 공유 잠금을 생성 하여 스케줄러 메소드가 실행될 때 get이 실행될 때마다 락 획득을 시킬 수 있다.
   + 단점: 모든 get 메소드 마다 락 시도를 해야함 + redis 안에 값이 많아져 덮어쓰는 시간이 길어 질수록 성능 저하 발생
   + 장점: 동기화로 데이터 일관성 보장
2. concurrentHashMap 안에 있는 값과 Redis에서 읽어온 값을 비교하여 없는 값들만 삭제해준 후 덮어 쓴다.
   + 장점: 성능 저하가 발생하지 않음(ConcurrentHashMap의 get이 CAS 알고리즘으로 동기화를 하지 않기때문에)
   + 단점: 데이터 일관성을 보장하지 못해 일정시간 에러가 발생할 수 있음.